from most_queue.sim import smo_im
from most_queue.sim import rand_destribution as rd
from most_queue.theory.ek_d_n_calc import Ek_D_n


def test():
    """
    Тестирование численного расчета многоканальной системы Ek/D/n
    с детерминированным обслуживанием

    Для вызова - используйте класс Ek_D_n пакета most_queue.theory.ek_d_n_calc
    Для верификации используем имитационное моделирование (ИМ).

    """

    ro = 0.8  # коэффициент загрузки СМО
    num_of_jobs = 800000  # количество заявок для ИМ. Чем больше, тем выше точночть ИМ
    n = 4  # число каналов

    # при создании экземпляра класса Ek_D_n нужно передать 4 параметра:
    # - l , k - параметры распределения Эрланга вх потока
    # - b - время обслуживания (детерминированное)
    # - n - число каналов обслуживания

    # Подберем параметры k и l аппроксимирующего распределения по среднему значению и коэфф вариации
    # с помощью метода most_queue.sim.rand_destribution.Erlang_dist.get_params_by_mean_and_coev()

    a1 = 1  # среднее время между заявками вх потока
    coev_a = 0.56  # коэффициент вариации вх потока
    k, l = rd.Erlang_dist.get_params_by_mean_and_coev(a1, coev_a)

    # время обслуживания определим на основе заданного коэффициента загрузки
    # В вашем случае параметры l, k, b и n могут быть заданы непосредственно.
    # Обязательно проверьте, чтобы коэфф загрузки СМО не превышал 1.0

    b = a1 * n * ro

    # создаем экземпляр класса для численного расчета
    ekdn = Ek_D_n(l, k, b, n)

    # запускаем расчет вероятностей состояний СМО
    p_ch = ekdn.calc_p()

    # для верификации используем ИМ.
    # создаем экземпляр класса ИМ, передаем число каналов обслуживания
    smo = smo_im.SmoIm(n)

    # задаем входной поток. Методу нужно передать параметры распределения списком и тип распределения. E - Эрланг
    smo.set_sources([k, l], "E")
    # задаем каналы обслуживания. На вход время обслуживания и тип распределения - D.
    smo.set_servers(b, "D")

    # запускаем ИМ:
    smo.run(num_of_jobs)

    # получаем параметры - начальные моменты времени пребывания и распределение веротяностей состояния системы
    v_im = smo.v
    p_im = smo.get_p()

    # выводим полученные значения:
    print("-" * 36)
    print("{0:^36s}".format("Вероятности состояний СМО E{0:d}/D/{1:d}".format(k, n)))
    print("-" * 36)
    print("{0:^4s}|{1:^15s}|{2:^15s}".format("№", "Числ", "ИМ"))
    print("-" * 36)
    for i in range(11):
        print("{0:^4d}|{1:^15.5g}|{2:^15.5g}".format(i, p_ch[i], p_im[i]))
    print("-" * 36)


if __name__ == "__main__":
    test()
