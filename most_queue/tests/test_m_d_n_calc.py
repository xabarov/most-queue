import numpy as np

from most_queue.sim.qs_sim import QueueingSystemSimulator
from most_queue.theory.m_d_n_calc import M_D_n


def test_mdn():
    """
    Тестирование расчета СМО M/D/n
    Для верификации используем имитационное моделирование (ИМ).
    """
    l = 1.0  # интенсивность входного потока
    ro = 0.8  # коэффициент загрузки
    n = 2  # количество каналов обслуживания
    num_of_jobs = 300000  # количество заявок для ИМ

    b = ro * n / l  # время обслуживания из заданного ro

    # расчет вероятностей состояний СМО
    mdn = M_D_n(l, b, n)
    p_ch = mdn.calc_p()

    # для верификации используем ИМ.
    # создаем экземпляр класса ИМ, передаем число каналов обслуживания
    qs = QueueingSystemSimulator(n)

    # задаем входной поток. Методу нужно передать параметры распределения и тип распределения.
    qs.set_sources(l, "M")

    # задаем каналы обслуживания. На вход параметры (в нашем случае время обслуживания)
    # и тип распределения - D (детерминированное).
    qs.set_servers(b, "D")

    # запускаем ИМ:
    qs.run(num_of_jobs)

    # получаем список начальных моментов времени пребывания в СМО
    v_sim = qs.v
    # получаем распределение вероятностей состояний СМО
    p_sim = qs.get_p()
    
    assert np.allclose(np.array(p_sim[:10]), np.array(p_ch[:10]), atol=1e-2)

    # Вывод результатов
    print("-" * 36)
    print("{0:^36s}".format("Вероятности состояний СМО M/D/{0:d}".format(n)))
    print("-" * 36)
    print("{0:^4s}|{1:^15s}|{2:^15s}".format("№", "Числ", "ИМ"))
    print("-" * 36)
    for i in range(11):
        print("{0:^4d}|{1:^15.5g}|{2:^15.5g}".format(i, p_ch[i], p_sim[i]))
    print("-" * 36)


if __name__ == "__main__":
    test_mdn()