from most_queue.sim import smo_im
from most_queue.theory.m_d_n_calc import M_D_n


def test():
    """
    Тестирование расчета СМО M/D/n
    Для верификации используем имитационное моделирование (ИМ).
    """
    l = 1.0  # интенсивность входного потока
    ro = 0.8  # коэффициент загрузки
    n = 2  # количество каналов обслуживания
    num_of_jobs = 800000  # количество заявок для ИМ

    b = ro * n / l  # время обслуживания из заданного ro

    # расчет вероятностей состояний СМО
    mdn = M_D_n(l, b, n)
    p_ch = mdn.calc_p()

    # для верификации используем ИМ.
    # создаем экземпляр класса ИМ, передаем число каналов обслуживания
    smo = smo_im.SmoIm(n)

    # задаем входной поток. Методу нужно передать параметры распределения и тип распределения.
    smo.set_sources(l, "M")

    # задаем каналы обслуживания. На вход параметры (в нашем случае время обслуживания)
    # и тип распределения - D (детерминированное).
    smo.set_servers(b, "D")

    # запускаем ИМ:
    smo.run(num_of_jobs)

    # получаем список начальных моментов времени пребывания в СМО
    v_im = smo.v
    # получаем распределение вероятностей состояний СМО
    p_im = smo.get_p()

    # Вывод результатов
    print("-" * 36)
    print("{0:^36s}".format("Вероятности состояний СМО M/D/{0:d}".format(n)))
    print("-" * 36)
    print("{0:^4s}|{1:^15s}|{2:^15s}".format("№", "Числ", "ИМ"))
    print("-" * 36)
    for i in range(11):
        print("{0:^4d}|{1:^15.5g}|{2:^15.5g}".format(i, p_ch[i], p_im[i]))
    print("-" * 36)


if __name__ == "__main__":
    test()
