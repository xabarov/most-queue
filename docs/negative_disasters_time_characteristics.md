# Временные характеристики СМО с «disaster» (отрицательные заявки, очищающие систему)

Этот документ описывает подход, используемый в Most-Queue для вычисления временных характеристик (время ожидания и время пребывания) в системах с **отрицательными заявками типа DISASTER**, которые при поступлении **мгновенно очищают систему** (удаляют всех клиентов из очереди и обслуживания).

## 1. Модель и термины

Рассматривается одноклассовая СМО с:

- положительными поступлениями (обычно пуассоновский поток) с интенсивностью \(\lambda\);
- обслуживанием со временем \(B\) (при численном расчёте в теории очередей часто аппроксимируется распределением \(H_2\) или \(C_2\); для имитационного моделирования обычно используется Gamma-распределение);
- отрицательными поступлениями (disaster) — пуассоновский поток с интенсивностью \(\delta\) (`l_neg`), который при событии disaster **удаляет всех клиентов из системы**.

В симуляторе `QsSimNegatives(..., NegativeServiceType.DISASTER)` семантика такая:

- если disaster случился в момент \(t\), то для всех клиентов, находящихся в системе, фиксируется их время пребывания как \(t - t_{\text{arrival}}\);
- для клиентов в очереди также фиксируется их накопленное ожидание как \(t - t_{\text{start\_wait}}\);
- система становится пустой мгновенно.

### Какие случайные величины мы хотим получить

Для «типичного» положительного клиента:

- \(W\) — **время ожидания в очереди** (до начала обслуживания **или** до disaster, если он случился раньше).
- \(V\) — **время пребывания в системе** (до завершения обслуживания **или** до disaster, если он случился раньше).

Также полезны условные характеристики:

- \(V_{\text{served}}\) — \(V\) при условии, что клиент **успешно обслужен** (завершил обслуживание до disaster).
- \(V_{\text{broken}}\) — \(V\) при условии, что клиент **удалён disaster** (disaster раньше завершения обслуживания).

## 2. Ключевая идея: «min(·, Exp(δ))» и LST

Пусть \(Y\sim \mathrm{Exp}(\delta)\) — время до **первого disaster после момента прихода клиента**.

Из независимости пуассоновских потоков следует, что \(Y\) независима от всего «внутреннего» поведения системы, если рассматривать его как функцию состояния в момент прихода.

Далее удобно определить две величины, которые относятся к **гипотетической** системе, где disasters *после прихода клиента выключены*:

- \(W_0\) — время до начала обслуживания клиента **если disasters после его прихода не происходят** (но стартуем из стационарного состояния системы с disasters в момент прихода).
- \(Z_0 = W_0 + B\) — время до завершения обслуживания клиента в той же «no-disaster-after-arrival» картине.

Тогда величины, соответствующие симуляции, выражаются через минимум:

- \(W = \min(W_0,\, Y)\)
- \(V = \min(Z_0,\, Y)\)

### 2.1. Формулы для LST

Обозначим преобразование Лапласа–Стилтьеса (LST):
\[
T^*(s) = \mathbb{E}\left[e^{-sT}\right],\quad s\ge 0.
\]

Для \(Y\sim \mathrm{Exp}(\delta)\) и независимого \(T\) верно:
\[
\mathbb{E}\left[e^{-s\min(T,Y)}\right]
= \frac{\delta}{s+\delta} + \frac{s}{s+\delta}\, T^*(s+\delta).
\]

Отсюда сразу:
\[
W^*(s) = \frac{\delta}{s+\delta} + \frac{s}{s+\delta}\, W_0^*(s+\delta),
\]
\[
V^*(s) = \frac{\delta}{s+\delta} + \frac{s}{s+\delta}\, Z_0^*(s+\delta).
\]

### 2.2. Как получать моменты из LST

Если \(T\) имеет моменты до порядка \(m\), то:
\[
\mathbb{E}[T^m] = (-1)^m \left.\frac{d^m}{ds^m}T^*(s)\right|_{s=0}.
\]

В коде Most-Queue для этого используется численное дифференцирование `scipy.misc.derivative(...)` (учтите, что в SciPy оно помечено как deprecated; при желании это можно заменить на более современную численную дифференцировку).

## 3. Одноканальный случай: `MG1Disasters`

Для M/G/1 с disasters используется PK-подобная формула в терминах LST (см. Jain & Sigman, 1996).

Важно: disaster влияет **и на ожидание, и на обслуживание** (через минимум с \(Y\)), поэтому простая «свёртка моментов» вида
\[
V \stackrel{\Large\text{x}}{=} W + \min(B,Y)
\]
в общем случае **неверна** — потому что \(Y\) может наступить во время ожидания, т.е. «обрезает» и \(W\), и \(B\).

Правильный подход в реализации `most_queue/theory/negative/mg1_disasters.py`:

- сначала строится LST ожидания \(W^*(s)\) для системы с очистками;
- затем LST времени пребывания выражается как:
\[
V^*(s)=\frac{\delta}{s+\delta}+\frac{s}{s+\delta}\,W^*(s+\delta)\,\beta(s+\delta),
\]
где \(\beta(s)=\mathbb{E}[e^{-sB}]\) — LST времени обслуживания.

## 4. Многоканальный случай: `MGnNegativeDisasterCalc` (Takahashi–Takami)

В многоканальном случае (M/H₂/n с дискретным уровнем и микросостояниями) прямой «закрытой» формулы типа PK нет, поэтому используется следующая конструкция:

1) **Стационарное распределение состояний** для системы с disasters вычисляется расширенным методом Такахаси–Таками (см. `docs/negative_queues_takahasi_takami.md`). Это даёт веса `Y[k][0, i]`, которые интерпретируются как вероятности того, что типичный приход увидит уровень \(k\) и микросостояние \(i\) (PASTA).

2) Для вычисления \(W_0^*(s)\) и \(Z_0^*(s)\) используется «гипотетическая» динамика *без disasters после прихода*, но **условная по состоянию, которое клиент увидел в системе с disasters**:

- если клиент пришёл при числе клиентов \(k<n\), то ожидание до старта обслуживания равно нулю, \(W_0=0\);
- если \(k\ge n\), то ожидание до старта обслуживания равно сумме времен завершения обслуживаний, необходимых, чтобы освободился сервер. В H₂‑модели это даёт LST как произведение экспоненциальных LST по интенсивностям, зависящим от микросостояния.

Технически в коде это реализовано как суммирование по уровням \(k\ge n\) с матричными степенями переходов «вверх» для базовой системы **без disasters** (`base_mgn.calc_up_probs(...)`), а не через ручную свёртку моментов.

3) После получения \(W_0^*(s)\) и \(Z_0^*(s)\) применяются общие формулы для minimum с экспонентой:

- \(W^*(s)\) через \(W_0^*(s+\delta)\)
- \(V^*(s)\) через \(Z_0^*(s+\delta)\)

4) Условные распределения для `served` и `broken` также выражаются через \(Z_0^*\):

- вероятность успешного обслуживания:
\[
p_{\text{served}} = \mathbb{P}(Z_0<Y)=\mathbb{E}[e^{-\delta Z_0}] = Z_0^*(\delta)
\]
- LST для обслуженных:
\[
\mathbb{E}[e^{-sV}\mid served] = \frac{Z_0^*(s+\delta)}{Z_0^*(\delta)}
\]
- LST для удалённых disaster:
\[
\mathbb{E}[e^{-sV}\mid broken] = \frac{\delta}{s+\delta}\,\frac{1-Z_0^*(s+\delta)}{1-Z_0^*(\delta)}
\]

## 5. Что это даёт на практике

- **Согласованность с симуляцией**: формулы \(W=\min(W_0,Y)\), \(V=\min(Z_0,Y)\) точно соответствуют тому, как симулятор завершает клиентов при disaster.
- **Корректность для любых параметров**: не требуется предполагать, что disaster влияет только на обслуживание или только на очередь.
- **Условные метрики served/broken** получаются из одной и той же базовой величины \(Z_0^*\) без дополнительных эвристик.

## 6. Связанные реализации в коде

- `most_queue/theory/negative/mg1_disasters.py` — M/G/1 с disasters, LST‑подход + моменты через производные.
- `most_queue/theory/negative/mgn_disaster.py` — M/H₂/n с disasters (расширение Такахаси–Таками) + вычисление \(W, V, V_{served}, V_{broken}\) через LST.
- `most_queue/sim/negative.py` — симуляционная семантика disasters (`NegativeServiceType.DISASTER`).

## 7. Ссылки

1. Jain, G., Sigman, K. *A Pollaczek–Khintchine formula for M/G/1 queues with disasters.* Journal of Applied Probability 33(4), 1996.
2. Gelenbe, E. *Product-form queueing networks with negative and positive customers.* J. Appl. Prob., 1991.

