# Временные характеристики СМО с отрицательными заявками RCS (Remove Customer in Service)

Этот документ описывает подход к вычислению временных характеристик в системах с отрицательными заявками типа **RCS** — при таком отрицательном событии из системы удаляется **одна заявка, находящаяся в обслуживании** (в симуляторе выбирается случайный занятый сервер).

Документ ориентирован на соответствие семантике симуляции `QsSimNegatives(..., NegativeServiceType.RCS)`.

## 1. Модель и ключевое отличие от DISASTER

Пусть:

- \(\lambda\) — интенсивность положительных поступлений;
- \(B\) — время обслуживания (в теории часто аппроксимируется \(H_2\) или \(C_2\); в имитации нередко используется Gamma);
- \(\delta\) — интенсивность отрицательных событий (RCS), `l_neg`.

**Отличие от DISASTER:**

- при DISASTER очищается вся система, т.е. отрицательное событие может завершить клиента и в очереди, и в обслуживании;
- при RCS отрицательное событие удаляет **только** клиента в обслуживании, очередь не затрагивается.

Отсюда следует важный вывод:

- время ожидания в очереди \(W\) **не обрезается** минимумом с \(\mathrm{Exp}(\delta)\), но **зависит** от \(\delta\), потому что RCS может освобождать серверы раньше (сервисный клиент удалён → сервер освобождён).

## 2. Семантика симуляции (RCS)

В `most_queue/sim/negative.py` для `NegativeServiceType.RCS`:

- если система пуста, отрицательное событие ничего не делает;
- иначе выбирается случайный занятый сервер и заявка в обслуживании удаляется;
- для удалённой заявки фиксируется время пребывания \(V\) как \(t - t_{\text{arrival}}\);
- ожидание \(W\) у удалённой заявки — то, что она накопила до начала обслуживания (если она успела начать обслуживание).

## 3. Эффективная «опасность удаления» в обслуживании

Когда в системе занято \(m\) серверов, каждое отрицательное событие выбирает один из \(m\) занятых серверов равновероятно. Поэтому для **конкретной** обслуживаемой заявки интенсивность удаления равна:
\[
r(m) = \frac{\delta}{m}.
\]

Если считать, что во время обслуживания \(m\) приблизительно постоянно, то время в обслуживании для типичной заявки становится:
\[
S = \min(B,\; Y),\quad Y\sim \mathrm{Exp}(r(m)).
\]

### 3.1. LST для \(\min(B, \mathrm{Exp}(r))\)

Для независимых \(B\) и \(Y\sim \mathrm{Exp}(r)\):
\[
S^*(s) = \mathbb{E}[e^{-s\min(B,Y)}]
= \frac{r}{s+r} + \frac{s}{s+r}\,\beta(s+r),
\]
где \(\beta(s)=\mathbb{E}[e^{-sB}]\) — LST обслуживания.

## 4. Ожидание \(W\): LST через структуру уровней (Takahashi–Takami)

В многоканальном методе Такахаси–Таками ожидание до начала обслуживания при FIFO можно получать через LST, суммируя по уровням \(k\ge n\) и микросостояниям (PASTA).

Для RCS меняется «время до следующего освобождения сервера» на уровне \(k\ge n\):

- в микросостоянии \(j\) суммарная интенсивность завершения обслуживания равна \(\text{service\_rate}(j)\);
- дополнительно сервер может освободиться из‑за RCS с интенсивностью \(\delta\) (удаляется кто‑то из обслуживаемых).

Поэтому в LST ожидания используется экспоненциальный фактор вида:
\[
\mathrm{Exp}(\text{service\_rate}(j) + \delta).
\]

Итоговая структура:

- с вероятностью \(\mathbb{P}(k<n)\) ожидание нулевое;
- дефектная часть \( \mathbb{E}[e^{-sW};\,k\ge n] \) вычисляется матричным суммированием по уровням.

В Most-Queue это реализовано в `most_queue/theory/negative/mgn_rcs.py` в виде функции LST ожидания \(W^*(s)\), после чего моменты получаются численным дифференцированием в нуле.

## 5. Пребывание в системе \(V\), served/broken

В RCS клиент может выйти двумя способами:

- **served**: обслуживание завершилось раньше удаления;
- **broken**: клиент удалён отрицательным событием во время обслуживания.

При фиксированном \(m\) (занятых серверов в момент старта обслуживания) условная структура проста:
\[
V = W + \min(B, \mathrm{Exp}(\delta/m)).
\]

Проблема на практике в том, что \(m\) зависит от состояния:

- если клиент приходит при уровне \(k<n\), он начинает обслуживаться сразу и естественно \(m=k+1\);
- если клиент приходит при уровне \(k\ge n\), он ждёт и затем, в грубом приближении, стартует сервис при \(m\approx n\).

В Most-Queue используется именно эта аппроксимация (смесь случаев \(k<n\) и \(k\ge n\)), но вычисление идёт через LST, чтобы:

- корректно учитывать, что \(W\) уже «включает» влияние \(\delta\);
- получить \(V\), \(V_{\text{served}}\), \(V_{\text{broken}}\) без ручной свёртки моментов с неверным ожиданием.

## 6. Связанные реализации в коде

- `most_queue/theory/negative/mgn_rcs.py` — M/H₂/n с отрицательными RCS.
- `most_queue/sim/negative.py` — симуляционная семантика `NegativeServiceType.RCS`.

